# Chapter 5 操作符和表达式

## 5.1 操作符

### 5.1.1 算术操作符

C提供了所有常用的算术操作符：

``` c
+   -   *   /   %
```

除了 `%` 操作符，其余几个操作符都是既适用于浮点类型又适用于整数类型。当 `/` 操作符的两个操作数都是整数时，它执行整除运算（如果整除运算的任一操作数为负值，运算的结果是由编译器定义的），其他情况下则执行浮点数除法。

### 5.1.2 移位操作符

- 左移操作符：`<<`

- 右移操作符：`>>`
    1. 逻辑移位：左边移入的位用0填充
    2. 算术移位：左边移入的位由原先该值的符号为决定

> 警告：标准说明无符号值执行的所有移位操作都是逻辑移位，但对于有符号值，采用逻辑移位还是算术移位取决于编译器。

> 警告： `a << -5`
> <br>
> 标准说明这类移位的行为是未定义的，它时由编译器决定的，它的结果很可能是没有意义的，应该避免使用这种类型的移位。

### 5.1.3 位操作符

位操作符有：

``` c
&   |   ^
```

![位操作符](image/2019-04-07-22-08-22.png)

``` c
/*
** 表达式假定变量 `bit_number` 为一整型值，范围是从0到整型值的位数减1，并且整型值的位从右向左技术。
*/

// 把指定的位设置为 1
value |= 1 << bit_number;

// 把指定的位清 0
value &= ~ (1 << bit_number);

// 对指定位进行测试，如果该位置为 1，则表达式的结果为非零值
value & 1 << bit_number;
```

### 5.1.4 赋值

赋值表达式的值就是左操作数的新值。

> 警告：`a = x = y + 3`
> <br>
> a 和 x 被赋予相同的值的说法是不正确的。如果 x 是一个字符型变量，那么 `y + 3` 的值就会被截去一段，以便容纳于字符类型的变量中。以下这个常见的错误中，这种截短正是问题的根源所在：
> ``` c
> char ch;
> ...
> while ((ch = getchar()) != EOF) ...
> ```
> EOF 需要的位数比字符型值所能提供的位数多，这也是 `getchar` 返回一个整型值而不是字符值的原因。在有符号字集的机器上运行时，如果读取了一个值为 `\377` 的字节时，循环将会终止，因为这个值截短再提升之于 EOF 相等。在无符号字符集的机器上运行时，这个循环将永远不会停止。

复合赋值符：

``` c
+=  -=  *=  /=  %=
<<= >>= &=  ^=  |=
```

`a += expression` 相当于 `a = a + (expression)`。

``` c
a[2 * (y - 6 * f(x))] = a[2 * (y -6 * f(x))] + 1;
a[2 * (y - 6 * f(x))] += 1;
```

在函数 `f` 没有副作用的情况下，他们是相等的。在第一种形式中，由于编译器不知道函数 `f` 是否具有副作用，所以它必须两次计算下标的值。第二种形式效率更高，因为下标只计算一次。

### 5.1.4 单目操作符

``` c
!   ++  -   &   sizeof
~   --  +   *   (类型)
```

`sizeof` 操作符判断它的操作数的类型长度，以字节为单位表示。操作数可以是个表达式（一般是单个变量），也可以是两边加上括号的类型名。

``` c
sizeof(int)     sizeof x
```

当 `sizeof` 的操作数是个数组名时，它返回该数组的长度，以字节为单位。在表达式的操作数两边加上括号也是合法的，如：`sizeof(x)`。判断表达式的长度并不需要对表达式进行求值，所以 `sizeof(a = b + 1)` 并没有向 `a` 赋任何值。

`++` 和 `--` 操作符实际只要求操作数必须是一个“左值”，即只能作用于可以位于赋值操作符左边的表达式。

> 前缀和后缀形式的增值操作符都复制一份变量值的拷贝。用于周围表达式的值正是这份拷贝。前缀操作符在进行复制之前增加变量的值，后缀操作符在进行复制之后才增加变量的值。这些操作符的结果不是它们所修改的变量，而是变量值的拷贝。

### 5.1.6 关系操作符

``` c
>   >=  <   <=  !=  ==
```

这些操作符产生的结果都是一个整型值，而不是布尔值。两端的操作数符合操作符指定的关系，表达式结果为 1， 如果不符合，表达式的结果为 0。

### 5.1.7 逻辑操作符

``` c
&&  ||
```

逻辑操作符，短路求值(short-circuited evaluation)

### 5.1.8 条件操作符

``` c
expression1 ? expression2 : expression3
```

### 5.1.9 逗号操作符

``` c
expression1, expression2, ..., expressionN
```

逗号操作符将两个或多个表达式分隔开来。这些表达式自左向右逐个进行求值，整个逗号表达式的值就是最后一个表达式的值。

``` c
a = get_value();
count_value(a);
while (a > 0) {
    ...
    a = get_value();
    count_value();
}

// 上面可以简化成
while (a = get_value(), count_value(a), a > 0) {
    ...
}
```

### 5.1.10 下标引用、函数调用和结构成员

后面介绍

## 5.2 布尔值

规则：**零是假，任何非零值皆为真。**

## 5.3 左值和右值

## 5.4 表达式求值

### 5.4.1 隐式类型转换

C的整型算术运算总是至少以缺省整型类型的精度来进行计算。所以表达式中的字符型和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升(integral Promotion)。

### 5.4.2 算术转换

下面的层次体系称为寻常算术转换(usual arithmetic conversion)

``` c
long double
double
float
unsigned long int
long int
unsigned int
int
```

如果某个操作数的类型在上面这个列表中排名较低，那么它首先将转换为另外一个操作数的类型后再执行操作。

### 5.4.3 操作符的属性

### 5.4.4 优先级和求值的顺序

> 表达式的求值顺序并非完全由操作符的优先级决定