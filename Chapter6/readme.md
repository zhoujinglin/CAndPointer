# Chapter 6 指针

## 6.1 内存和地址

尽管一个字包含了4个字节，它仍然只有一个地址。至于它的地址是它最左边那个字节的位置还是最右边那个字节的位置，不同的机器有不同的规定。另一个需要注意的硬件事项是边界对齐(boundary alignment)。在要求边界对齐的机器上，整型值储存的起始位置只能是某些特定的字节，通常是2或4的倍数。

名字与内存位置之间的关联并不是硬件所提供的，它是由编译器为我们实现的。所有这些变量给了我们一种更方便的方法记住地址——硬件仍然通过地址访问内存位置。

## 6.2 值和类型

## 6.3 指针变量的内容

变量的值是分配给该变量的内存位置所储存的数值，即使是指针变量也不例外。

## 6.4 间接访问操作符

间接访问(indirection)

解引用指针(dereferencing the pointer)

## 6.5 未初始化和非法指针

在对指针进行间接访问之前，必须非常小心，确保它们已被初始化。

## 6.6 NULL指针

标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针变量为NULL，你可以给它赋一个零值。为了测试一个指针变量是否为NULL，你可以将它与零值进行比较。

## 6.7 指针、间接访问和左值

``` c
int a;
int *d = &a;
```

| 表达式 | 左值 | 指定位置 |
| :-: | :-: | :-: |
| a | 是 | a |
| d | 是 | d |
| *d | 是 | a |

## 6.8 指针、间接访问和变量

## 6.9 指针常量

``` c
*100 = 25;
```

它看上去像是把25赋值给位置100所储存的变量。但是，这是错的。这条语句是非法的，因为字面值100的类型是整型。如果确实想把25储存在位置100，你必须使用强制类型转换：

``` c
*(int *)100 = 25;
```

## 6.10 指针的指针

## 6.11 指针表达式

``` c
char ch = 'a';
char *cp = &ch;
```

`ch` 作为右值使用时，表达式的值为 `'a'`，如下图所示：

![右值](image/2019-04-12-20-51-47.png)

那个粗椭圆提示变量`ch`的值就是表达式的值。但是当这个表达式作为左值使用时，它是这个内存地址而不是该地址所包含的值，所以它的图示方式有所不同：

![左值](image/2019-04-12-20-54-03.png)

![&ch](image/2019-04-12-20-55-36.png)

作为右值，这个表达式的值是变量 `ch` 的地址。

![cp](image/2019-04-12-20-57-06.png)

![&cp](image/2019-04-12-20-57-24.png)

![*cp](image/2019-04-12-20-58-20.png)

![*cp + 1](image/2019-04-12-20-59-13.png)

 `*` 的优先级高于 `+`，所以先执行间接访问操作（如图中 `cp` 到 `ch` 的实线箭头所示），我们可以得到它的值。我们取得这个值的一份拷贝并把它与1相加，表达式的最终结果为字符 `'b'` 。图中虚线表示表达式求值时数据的移动过程。

![*(cp + 1)](image/2019-04-12-21-03-42.png)

![++cp](image/2019-04-12-21-06-09.png)

在这个表达式中，我们增加了指针变量 `cp` 的值。表达式的结果是增值后的指针的一份拷贝。这份拷贝的存储位置并未清晰定义，所以它不是一个合法的左值。

![cp++](image/2019-04-12-21-09-23.png)

后缀 `++` 操作符同样增加 `cp` 的值，但它先返回 `cp` 的值。这样，这个表达式的值就是 `cp` 原本的值的一份拷贝。

![*++cp](image/2019-04-12-21-11-58.png)

这里，间接操作符作用于增值后的指针的拷贝上，所以它的右值是 `ch` 后面那个内存地址的值，而它的左值就是那个位置本身。

![*cp++](image/2019-04-12-21-14-08.png)

这里涉及3个步骤：（1） `++` 操作符产生 `cp` 的一份拷贝，（2）然后 `++` 操作符增加 `cp` 的值，（3）最后，在 `cp` 的拷贝上执行间接访问操作。

![++*cp](image/2019-04-12-21-18-28.png)

首先执行的是间接访问操作。然后， `cp` 所指向的位置的值增加1，表达式的结果是这个增值后的值的一份拷贝。

![(*cp)++](image/2019-04-12-21-22-49.png)

这个表达式的计算过程与前一个表达式相似，但它的结果值是 `ch` 增值前的1原先值。

![++*++cp](image/2019-04-12-21-24-30.png)

![++*cp++](image/2019-04-12-21-26-34.png)

## 6.12 实例

## 6.13 指针运算

指针加上一个整数的结果是另一个指针。

### 6.13.1 算术运算

第1中形式：

``` c
指针 +/- 整数
```

标准定义这种形式只能用于指向数组中某个元素的指针。并且这类表达式的结果类型也是指针。这种形式也适用于使用 `malloc` 函数动态分配获得的内存。

第2种形式：

```c
指针 - 指针
```

只有当两个指针指向同一个数组中的元素时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 `ptrdiff_t` ，它是一种有符号整数类型。

### 6.13.2 关系运算

``` c
<   <=  >   >=
```

前提是它们指向同一个数组中的元素。但是，可以在两个任意的指针间执行相等或者不相等测试。