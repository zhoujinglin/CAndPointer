# Chapter 8 数组

## 8.1 一维数组

### 8.1.1 数组名

数组名的值是一个指针常量，也就是数组第1个元素的地址。注意这个值是一个指针常量，而不是指针变量。不能修改常量的值。

``` c
int a[10];
int b[10];
...
c = &a[0];
/* `&a[0]` 是一个指向数组第一个元素的指针。但那正是数组名本身的值，所以下面这条语句和上面那条赋值语句是完全一致的 */
c = a;

b = a;
/* 这是非法的。不能使用赋值符把一个数组的所有元素复制到另一个数组。必须使用循环，每次复制一个元素。 */
a = c;
/* 这也是非法的，a 的值是个常量，不能修改 */
```

### 8.1.2 下标引用

除了优先级外，下标引用和简介访问是完全相同的。下面两个表达式是等同的：

``` c
array[index]
*(array + (index))
```

``` c
int array[10];
int *ap = array + 2;
// 结果是 ap 指向 array[2]

/* 写出使用 array 的对等表达式 */
ap
// array + 2，另外 &array[2] 也是它的对等表达式
*ap
// array[2] 或者 *(array + 2)
ap + 6
// array + 8 或者 &array[8]
*ap + 6
// 间接访问的优先级高， array[2] + 6
*(ap + 6)
// array[8]
ap[6]
// 把这个下标表达式转换为与其对应的间接访问表达式形式，它就是上面那个表达式，所以它们的答案相同
&ap
// 这个表达式合法，但是此时没有对等的涉及 array 的表达式，因为无法预测编译器会把 ap 放在相对于 array 的什么位置
ap[-1]
// 转换为对应的间接访问表达式 *(ap - 1) ，所以我们得到它的前一个元素，也就是 array[1]
ap[9]
// 它所指向的位置越过了数组的右边界。根据标准，这个表达式是非法的。但是，很少有编译器能够检测到这类错误，所以程序能够顺利地继续运行。
2[array]
// 它是合法的。把它转换成对等的间接访问表达式， `*(2 + (array))` ，它和 `*(array + 2)` 是等效的。所以，这个表达式与 `array[2]` 相等。
```

### 8.1.3 指针与下标

> 假定这两种方法都是正确的，下标绝不会比指针更有效率，但指针有时会比下标更有效率。

1. 当你根据某个固定数目的增量在一个数组中移动时，使用指针变量比使用下标产生效率更高的代码。当这个增量是1并且机器具有地址自动增量模型时，这点表现得更为突出。

2. 声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高。

3. 如果可以通过测试一些已经初始化并经过调整的内容来判断循环是否应该终止，那么你就不需要使用一个单独的计数器。

4. 那些必须在运行时求值的表达式较之诸如 `&array[SIZE]` 或 `array + SIZE` 这样的常量表达式往往代价更高。

### 8.1.5 数组和指针

指针和数组并不是相等的。

``` c
int a[5];
int *b;
```

声明一个数组时，编译器将根据声明所指定的元素数量为数组保留内存空间，然后创建数组名，它的值是一个常量，指向这段空间的起始位置。声明一个指针变量时，编译器只为指针本身保留内存空间，它并不为任何整型值分配内存空间。

![a[5] *b](image/2019-04-15-21-34-31.png)

上述声明之后，表达式 `*a` 是完全合法的，但表达式 `*b` 是非法的。另一方面， `b++` 可以通过编译，但 `a++` 却不行，因为 `a` 的值是个常量。

### 8.1.6 作为函数参数的数组名

### 8.1.7 声明数组参数

``` c
int strlen(char *string);
int strlen(char string[]);
```

这两个声明确实相等，但只是在当前这个上下文环境中。可以使用任何一种声明，但指针更加准确。因为实参实际上是个指针，而不是数组。同样， `sizeof string` 的值是指向字符的指针的长度，而不是数组的长度。

### 8.1.8 初始化

``` c
int vector[5] = {10, 20, 30, 40, 50};
```

#### 静态和自动初始化

储存于静态内存的数组只初始化一次。如果数组未指定值，数组的初始值将会自动设置为零。当程序执行时，静态数组已经初始化完毕。

当数组的初始化局部于一个函数（或代码块）时，应该仔细考虑一下，在程序的执行流每次进入该函数（或代码块）时，每次都对数组进行初始化是不是值得。如果不是，可以把数组声明为 `static` ，这样数组的初始化只需在程序开始前执行一次。

### 8.1.9 不完整的初始化

``` c
int vector[5] = {1, 2, 3, 4, 5, 6};
int vector[5] = {1, 2, 3, 4};
```

第1个声明是错误的。第2个声明是合法的，它为数组的前4个元素提供了初始值，最后一个元素则初始化为0。

### 8.1.10 自动计算数组长度

``` c
int vector[] = {1, 2, 3, 4, 5};
```

如果声明中未给出数组的长度，编译器就把数组的长度设置为刚好能够容纳所有的初始值的长度。如果初始值列表经常修改，这个技巧尤其有用。

### 8.1.11 字符数组的初始化

``` c
char message[] = {'H', 'e', 'l', 'l', 'o', 0};
// 这个方法可行，但很笨拙。因此，语言标准提供了一种快速方法用于初始化字符数组。
char message[] = "Hello";
// 它看上去像是一个字符串常量，实际上并不是。它只是前例初始化列表的另一种写法。
```

当用于初始化一个字符数组时，它就是一个初始化列表。在其他任何地方，它都表示一个字符串常量。

``` c
char message1[] = "Hello";
char *message2 = "Hello";
```

前者初始化一个字符数组的元素，而后者则是一个真正的字符串常量。这个指针变量被初始化为指向这个字符串常量的储存位置。

![字符数组](image/2019-04-15-23-38-15.png)

## 8.2 多维数组

### 8.2.1 储存顺序

在C中，多维数组的元素储存顺序按照最右边的下标率先变化的原则，称为行主序(row major order)。

### 8.2.2 数组名

``` c
int matrix[3][10];
```

matrix 可以看作是一个一维数组，包含3个元素，只是每个元素恰好是包含10个整型元素的数组。`matrix` 这个名字的值是一个指向它第1个元素的指针，所以 `matrix` 是一个指向一个包含10个整型元素的数组的指针。

### 8.2.3 下标

``` c
int matrix[3][10];

// 以下表达式是等价的
matrix[1][5]

*(*(matrix + 1) + 5)

*(matrix[1] + 5)
```

对于多维数组，下标仍然是另一种形式的间接访问表达式。

### 8.2.4 指向数组的指针

``` c
int vector[10], *vp = vector;
int matrix[3][10], *mp = matrix;
/* 第1个声明是合法的。但第2个声明是非法的。它正确的创建了 matrix 数组，并把 mp 声明为一个指向整型的指针。但是， mp 的初始化是不正确的，因为 matrix 并不是一个指向整型的指针，而是一个指向整型数组的指针。正确的声明如下： */
int (*p)[10];
/* 由于括号的存在，首先执行间接访问，所以 p 是一个指针。接下来是下标引用，所以 p 指向某种类型的数组。综上， p 指向一个拥有 10 个整数的整型数组。在声明中加上初始化后是下面这个样子： */
int (*p)[10] = matrix;
/* 它使 p 指向 matrix 的第1行。 */

int *pi = &matrix[0][0];
int *pi = matrix[0];
/* 以上两个声明可以用来逐个访问数组中的元素而不是逐行在数组中移动。 */
```

> 警告：如果打算在指针上执行任何指针运算，应该避免这种类型的声明：
> ``` c
> int (*p)[] = matrix;
> ```
> p 仍然是一个指向整型数组的指针，但数组长度不见了。当某个整数与这种类型的指针执行运算时，它的值将根据空数组的长度进行调整（也就是说，与零相乘）。有些编译器可以捕捉这类错误，但有些编译器却不能。

### 8.2.5 作为函数参数的多维数组

多维数组的每个元素本身是另外一个数组，编译器需要知道它的维数，以便为函数形参的下标表达式求值。

``` c
int vector[10];
...
func1(vector);
/*参数 vector 的类型是一个指向整型的指针，所以 func1 的原型可以是下面两种中的任意一种*/
void func1(int *vec);
void func1(int vec[]);
```

``` c
int matrix[3][10];
...
func2(matrix);
/* 可以有下面两种选择 */
void func2(int (*mat)[10]);
void func2(int mat[][10]);
```

在编写以为数组形参的函数原型时，既可以把它写成数组的形式，也可以把它写成指针的形式。但是，对于多维数组，只有第1维可以如此选择。其余维度必须用数组形式并声明长度。

### 8.2.6 初始化

第1种只给出1一个长长的初始值列表：

``` c
int matrix[2][3] = {100, 101, 102, 110, 111, 112};
```

第2种方法基于多维数组实际上是复杂元素的一维数组这个概念：

``` c
int two_dim[3][5] = {
    {00, 01, 02, 03, 04},
    {10, 11, 12, 13, 14},
    {20, 21, 22, 23, 24}
};
```

缺省的元素会被自动初始化为0。

### 8.2.7 数组长度自动计算

只有第1维才能根据初始化列表缺省地提供。剩余的几个维必须显式地写出。

``` c
int two_dim[][5] = {
    {00, 01, 02},
    {10, 11},
    {20, 21, 22, 23}
};
```

## 8.3 指针数组

``` c
int *api[10];
```

首先执行下标引用，因此 api 是一个大小为 10 的数组。在执行间接访问操作，所以， api 是一个大小为10 的整型指针数组。

``` c
/*指针数组的使用地方*/
char const *keyword[] = {
    "do",
    "for",
    "if",
    "register",
    "return",
    "switch",
    "while"
};
#define N_KEYWORD (sizeof(keyword) / sizeof(keyword[0]))
```

## 8.4 总结

在绝大多数表达式中，数组名的值是指向数组第1个元素的指针。这个规则只有两个例外。`sizeof` 返回整个数组所占用的字节而不是一个指针所占用的字节。单目操作符 `&` 返回一个指向数组的指针，而不是一个指向数组第1个元素的指针的指针。

## 8.7 问题

![8.7.8](image/2019-04-16-14-47-58.png)

在第一个赋值语句中，编译器认为a是一个指针变量，所以它提取存储在那里的指针值，并加上12（3个整型长度），然后对这个结果执行间接访问操作。但a实际上是整型数组的起始位置，所以作为“指针”获得的这个值实际上是数组的第一个整型元素，它与12相加，其结果解释为一个地址，然后对它执行间接访问，作为结果，它将提取一些任意内存位置的内容，或者由于某种地址错误而导致程序失败。

第二个赋值中，编译器认为b是个数组名。所以它把12（3的调整结果）加到b的存储地址，然后间接访问操作从那里获得值，事实上b是一个指针变量，所以从内存中提取的后面三个字实际上是从另外的任意变量中取得的，这个问题说明了指针和数组虽然存在关联，但绝不会是相同的。